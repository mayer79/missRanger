---
title: "Using missRanger"
date: "`r Sys.Date()`"
bibliography: "biblio.bib"
link-citations: true
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using missRanger}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Overview

{missRanger} uses {ranger} [@wright] for fast missing value imputation by chained random forest. As such, it is an alternative to {missForest}, a beautiful algorithm introduced in [@stekhoven]. Basically, each variable is imputed by predictions from a random forest using all other variables as covariates. The main function `missRanger()` iterates multiple times over all variables until the average out-of-bag prediction error of the models stops improving.

Why should you consider {missRanger}?

- It is fast.
- It is flexible and intuitive to apply: E.g., calling `missRanger(data, . ~ 1)` would impute all variables univariately, `missRanger(data, Species ~ Sepal.Width)` would use `Sepal.Width` to impute `Species`.
- It works for a variety of data types.
- It combines random forest imputation with predictive mean matching. This avoids "new" values like 0.3334 in a 0-1 coded variable and helps to raise the variance of the imputations, which is especially important for multiple imputation.

## Installation

```r
# From CRAN
install.packages("missRanger")

# Development version
devtools::install_github("mayer79/missRanger")
```

## Usage

We first generate data with 20% missing values per column. Then we fill them by `missRanger()`.

``` {r}
library(missRanger)

set.seed(84553)

head(iris)

irisWithNA <- generateNA(iris, p = 0.2)
head(irisWithNA)
 
irisImputed <- missRanger(irisWithNA, num.trees = 100, verbose = 0)
head(irisImputed)
```

### Predictive mean matching

It worked, but the new values appear overly exact. To avoid this, we can activate predictive mean matching (PMM):

``` {r}
irisImputed <- missRanger(irisWithNA, pmm.k = 3, num.trees = 100, verbose = 0)
head(irisImputed)
```

### Controlling the random forests

`missRanger()` offers many options to control the random forests grown by `ranger()`. Additional options to `ranger()` can be passed via `...`. How would we use one feature per split (mtry = 1) with 50 trees?

``` {r}
irisImputed_et <- missRanger(
  irisWithNA, pmm.k = 3, mtry = 1, num.trees = 50, verbose = 0
)
head(irisImputed_et)
```

### Use in Pipe

{missRanger} also plays well together with the pipe:

```{r}
iris |>
  generateNA() |>
  missRanger(verbose = 0, pmm.k = 5) |>
  head()
```

### Extended output

Setting `data_only = FALSE` returns a "missRanger" object containing more information. Use `imp$data` to extract the imputed data.

```{r}
(imp <- missRanger(irisWithNA, data_only = FALSE, verbose = 0))
summary(imp)
```

### Formulas

By default, `missRanger()` uses all columns to impute all columns with missings.

This can be modified by passing a formula: The left hand side specifies the variables to be imputed, while the right hand side lists the variables used for imputation.

``` {r}
# Impute all variables with all (default behaviour)
m <- missRanger(
  irisWithNA, formula = . ~ ., pmm.k = 3, num.trees = 10, seed = 1, verbose = 0
)

# Don't use Species for imputation
m <- missRanger(irisWithNA, . ~ . - Species, pmm.k = 3, num.trees = 10, verbose = 0)

# Impute Sepal.Width by Species(?)
m <- missRanger(
  irisWithNA, Sepal.Width ~ Species, pmm.k = 3, num.trees = 10
)
head(m)

# Only univariate imputation was done. Why? Because Species contains missing values
# itself and needs to appear on the lhs as well:
m <- missRanger(
  irisWithNA, Sepal.Width + Species ~ Species, pmm.k = 3, num.trees = 10
)
head(m)

# Impute all variables univariately
m <- missRanger(irisWithNA, . ~ 1, verbose = 0)
```

### Speed-up things

`missRanger()` is based on iteratively fitting random forests for each variable with missing values. For larger datasets, imputation can take long. Some tweaks to make things faster:

- Use less trees, e.g., `num.trees = 20`.
- Use smaller bootstrap samples, e.g., `sample.fraction = 0.1`.
- Use a smaller tree depth, e.g., `max.depth = 6`.
- Use large leaves, e.g., `min.node.size = 100`.
- Use less iterations, e.g., `max.iter = 2`.

### Trick: Use `case.weights` to reduce impact of rows with many missings

Using the `case.weights` argument, you can pass case weights to the imputation models. For instance, this allows to reduce the contribution of rows with many missings:

``` {r}
m <- missRanger(
  irisWithNA,
  num.trees = 20,
  pmm.k = 3,
  seed = 5,
  verbose = 0,
  case.weights = rowSums(!is.na(irisWithNA))
)
```

## References
